---
layout:     post
title:      "内部类"
subtitle:   " \"内部类..\""
date:       2018-01-29 12:00:00
author:     "ALID"
header-img: "img/post-bg-2015.jpg"
catalog: true
tags:
    - 基类
    - Meta
---
### 内部类
内部类是个编译时的概念，一旦编译成功后，它就与外围类属于两个完全不同的类（当然它们之间还是有联系的）。对于一个名为Outer的外围类和一个名为Inner的内部类，在编译成功后，会出现这样两个class文件：``Outer.class`` 和 ``Outer$Inner.class``。

#### 成员内部类
成员内部类隐式的```持有外部类的一个引用```,而静态内部类是没有的.
```java
public class Outer {
    
    private void outerDo() {}
    
    class Inter {
        
        private void innerDo() {
            // 内部类可以直接访问外部类成员，原因在于隐式持有了一个外部类引用
            outerDo();
            // Outer.this 就是内部类隐式持有的外部类引用
            Outer.this.outerDo();
        }
    }
}

```
##### 内部类和静态内部类的区别
根据Oracle官方的说法：
>Nested classes are divided into two categories: static and non-static. Nested classes that are declared static are called static nested classes. Non-static nested classes are called inner classes.

从字面上看，一个被称为静态嵌套类，一个被称为内部类。

嵌套的意思，是我完全可以独立存在，但我就是想借你的壳用一下，隐藏一下我自己。它是一个独立的类，完全是形式上的“内部”，和外部类没有本质上“内外”的关系。

而成员内部类和静态内部类不同的是，每一个成员内部类的实例都依赖一个外部类的实例。其它类使用内部类必须要先创建一个外部类的实例。成员内部类和外部类的关联更强一点.

成员内部类不能定义静态方法和变量（final修饰的除外）。
1. 非static的内部类，在外部类加载的时候，并不会加载它，所以它里面不能有静态变量或者静态方法。

>1、static类型的属性和方法，在类加载的时候就会存在于内存中。
>
>2、要使用某个类的static属性或者方法，那么这个类必须要加载到jvm中。
基于以上两点，可以看出，如果一个非static的内部类如果具有static的属性或者方法，那么就会出现一种情况：内部类未加载，但是却试图在内存中创建static的属性和方法，这当然是错误的。原因：类还不存在，但却希望操作它的属性和方法。

2. java很多想这类不能共同存在的 一般都与他们的生命周期有关。
比如 静态成员和静态方法是随着类的加载而存在的，也就是说内部类的静态属性是随着类的加载的，但是内部类的实例 是创建后才存在的，也就是说其静态属性优先存在于他的类实例的存在 这显然是矛盾的，所以要把内部类设为静态的 这样他们的生命周期就是相同了；

3. 如果内部类没有static的话，就需要实例化内部类才能调用，说明非static的内部类不是自动跟随主类加载的，而是被实例化的时候才会加载。
而static的语义，就是主类能直接通过内部类名来访问内部类中的static方法，而非static的内部类又是不会自动加载的，所以这时候内部类也要static，否则会前后冲突。

**一个类需要被定义成static的，只有一种情况，就是静态内部类。**