---
layout:     post
title:      "并发系统设计"
subtitle:   "按照场景区分不同情况下的并发设计"
date:       2019-11-02 12:00:00
author:     "ALID"
header-img: "img/post-bg-palace.jpeg"
catalog: true
tags:
    - 并发
    - 设计
---

> 虽然都是高QPS但有不同的类型,我将从缓存/业务类型等方面分开来分析

### 全量缓存

这种场景,一般都可以将使用计算结果**全部存到内存或redis中**, 这样我们可以不用考虑缓存穿透, 缓存雪崩以及缓存击穿的问题.

但也需要考虑一些问题

1. 缓存更新: 需要定时或增加触发机制保证缓存的更新

2. 缓存同步: 如果使用本地缓存,则需要保证不同机器缓存同步更新

3. 机器限流: 即使是本地缓存也不能无限制承受QPS,需要考虑使用队列削峰,或者根据业务场景也可以采用拒绝策略.

4. 监控: 如果缓存不是实时计算的就要有监控保证我缓存的有效性. 监控缓存为空和查询超时的情况.并且缓存为空应该及时报警并刷新缓存.

### 查询实时结果

这种场景, 需要根据每次请求计算不同的结果. 设计就要复杂很多, 需要考虑是否异步,以及缓存穿透, 缓存雪崩以及缓存击穿的问题.

#### 1. 交互方式

首先从和调用方的交互说起, 这样的请求一般有两种情况. 

1. 不需要大量计算, 可以很快返回结果: 一般不需要考虑异步请求, 直接使用同步请求即可

2. 需要实时计算, 或者生成结果较慢的情况: 这种情况也可以采用两种方式.
   
   - 异步回调: 这种方式的请求方不需要等待返回, 而是消费者再生成结果的时候回调请求方的回调接口将信息返回. `dubbo`就支持这种异步请求的方式, 请求结果放到一个`future`中, 提前请求使用所需资源. 之后集中使用.
   
   - 多次请求: 这种方式会至少发两次请求,接收到请求的时候消费者会直接查缓存, 如果缓存中有结果(热点数据)可以直接返回 (**??? 是否要再算一次保证缓存的更新**). 如果没有结果直接返回默认值, 并开始计算. 计算完成后存到缓存中. 当调用方再次请求的时候, 还是在缓存中查询. 但这次因为刚刚生成了缓存, 就可以查询到结果. 

对应以上两种方式, 多次请求的方式可以减少系统的**耦合**, 适用于会生成**多批**结果的场景. 例如机票报价查询平台就会请求多次, 每次会返回计算较快的报价, 之后每次查询可能都会得到新的报价.

而异步回调的方式更适用于返回**结果单一**且**对结果依赖性较强**, 调用方需要拿到结果进行下一步计算的情况. 例如机票报价系统中, 会在产生报价的时候请求很多资源, 比如:政策, 代理商接口等. 其中代理商报价系统因为是http外部接口一般要慢一些, 这样的话我就可以异步请求代理商系统, 该系统在拿到报价后回调, 接受到回调之后就可以将结果写到缓存中, 以供之后计算使用.

> 这只是交互方式, 我们还需要考虑缓存/DB等问题

#### 2. 缓存设计

一般情况下, 都有热点数据, 这里也是基于考虑热点数据的场景进行设计

**本地缓存**

一般每次请求都会先查询本地缓存, 可以使用**LRU算法**保证热点数据在缓存中驻留. 如果是时效性较强的场景, 还需要对于每个缓存记录查询次数. 如果**超过限制次数**也会和失效一样触发缓存更新.

**分布式缓存**

本机内存做的缓存是查询最快的, 但是因为分布式等问题, 除了可以做全量缓存的情况, 例如酒店搜索, 其他大多数情况一般都不考虑每台机器全量缓存. 所以就需要使用分布式缓存存放热点数据, 例如redis.

redis的数据可以在本地缓存失效的时候刷新到redis中, 这里也要考虑缓存的时效性问题. 但实际上缓存时效性问题的确会发生, 例如机票报价的价格之后改变了, 可以在下单的时候再次check价格, 如果变化较大可以提示用户价格变动, 避免损失. P.s.一般情况还是按照查询时价格生单.

> 虽然我们设计好了缓存, 但是缓存也会面临一些问题.

**缓存穿透**

访问一个不存在的key，缓存不起作用，请求会穿透到DB，流量大时DB会挂掉。可以采用以下方式尝试:

1. 采用布隆过滤器，使用一个足够大的bitmap，用于存储可能访问的key，不存在的key直接被过滤；
2. 访问key未在DB查询到值，也将空值写进缓存，但可以设置较短过期时间。

**缓存雪崩**

大量的key设置了相同的过期时间，导致在缓存在同一时刻全部失效，造成瞬时DB请求量大、压力骤增，引起雪崩。可以采用以下方式尝试:

可以给缓存设置过期时间时加上一个随机值时间，使得每个key的过期时间分布开来，不会集中在同一时刻失效。

**缓存击穿**

一个存在的key，在缓存过期的一刻，同时有大量的请求，这些请求都会击穿到DB，造成瞬时DB请求量大、压力骤增。可以采用以下方式尝试:

在访问key之前，采用SETNX（set if not exists）来设置另一个短期key来锁住当前key的访问，访问结束再删除该短期key。

#### 3. DB

一般对应高并发请求, 都较少和数据库打交道, 但是也不可能完全脱离DB. 这里说的是查询的情况, 一般是不需要有写入操作的. 但是也难免会有请求需要查库, 这里除了需要考虑缓存穿透和缓存击穿的问题以外. 还有考虑 **???** 

### 秒杀

> 这种场景和刚刚的查询不一样的地方, 是需要修改记录. 最需要关注的是**修改库存**

我们知道只要创建订单，就要频繁操作数据库 IO。那么有没有一种不需要直接操作数据库 IO 的方案呢?

这就是预扣库存。先在**本地缓存**中扣除了库存，保证不超卖。之后在返回给用户支付页面的时候, **异步**生成用户订单，这样响应给用户的速度就会快很多；那么怎么保证不少卖呢？用户拿到了订单，不支付怎么办？我们都知道现在订单都有有效期，比如说用户五分钟内不支付，订单就失效了，订单一旦失效，就会加入新的库存，这也是现在很多网上零售企业保证商品不少卖采用的方案。

订单的生成是异步的，一般都会放到 MQ、Kafka 这样的即时消费**队列**中处理，如果再加上队列的话对数据库的压力也比较小. 并且订单量比较少的情况下，生成订单非常快，用户几乎不用排队。

![](https://octopus.smcdn.cn/basic/_97b2891aaef807858e93ffb183594b5a/md5/302c663675a700c94d3bec19fcf7aed9.png)

以上就是大致的系统设计图, 用户100w请求量, 均摊到100台机器上. 每台机器分配好**100单库存**, 这里你可能注意到了我标出的`+50`. 

说清楚这点需要我们再考虑一种情况, 如果有机器在秒杀的时候宕机怎么办? 那不就少卖了吗. 所以考虑再每个机器上增加一些**冗余库存** (当然不一定要定为50单) 也就是每台机器都**存放150单**. 因为每次生单前必须要**本地和redis都减库存成功**, 可以保证不超卖. 而且这样就可以防止有些机器宕机后, 该机器上的票没有卖出去的情况.

之后在减库存成功后, 异步发送MQ队列修改DB, 已经生单的操作.

> 其实这种方案, 是把redis当做DB使用了. 最简单的设计方案就是每次减库存都要在数据库完成, 但因为并发的瓶颈不能直接请求DB, 所以使用redis完成了DB的部分功能.

如果QPS不高的情况呢? 我们完全可以直接把库存记录在redis上, 直接在redis上减库存. 也就不需要将订单分到机器了.

### 一致性问题

> 设计到分布式, 并发就不得不提到一致性问题.

1. DB一致性


